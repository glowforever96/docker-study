# 1. 가상화 기술

## 애플리케이션 서버

**서버 : 하드웨어에서 실행 중인 소프트웨어**

서버는 항상 원하는 결과를 응답(response), 원하는 행동(request)을 요청하는 주체는 클라이언트(Client)

서버에서 어떤 소프트웨어가 실행중인지에 따라 다양한 서버로 분류

- 파일서버
- DB서버
- 웹서버
- 웹애플리케이션서버(WAS)

엔터프라이즈 환경에서는 아주 많은 양의 서버를 운영, 서버를 운영하는 방법은 크게 세가지

1. 베어메탈(Baremetal) 
    - 일반적으로 컴퓨터를 구입하고 프로그램을 실행시키는 방식과 비슷
    - 서버를 하나 구입한 다음 서버 위의 OS에서 여러개의 소프트웨어를 실행
    - 비효율적
2. 하이퍼바이저(Hypervisor)
3. 컨테이너(Container)

## 가상화기술과 하이퍼바이저 가상화

`가상화기술 : 실제로 존재하는 컴퓨터가 아니지만 마치 존재하는 것처럼 만들어주는 기술` → `물리적인 컴퓨팅 환경에서 내부에서 논리적인 컴퓨팅 환경을 만드는 기술`

- 가상화 기술을 사용하면 한대의 컴퓨터에 여러 대의 논리적인 OS 환경 만들수 있음
- 가상으로 만들어진 컴퓨터에 사용자가 리소스를 직접 분배 → 하나의 가상 OS가 사용할 수있는 리소스의 최대값을 정할 수 있음

**가상화 기술로 하나의 하드웨어를 효율적으로 활용하는 것이 엔터프라이즈 환경에선 필수적**

### 하이퍼바이저 가상화

하이퍼바이저 → 컴퓨터에 설치되는 프로그램 (가상 OS를 만들거나 가상 OS를 실행시키고 종료)

- 호스트 OS : 물리적인 서버에 설치되는 OS, 하이퍼바이저를 설치해 가상환경을 만듬
    - 하이퍼바이저는 호스트 OS의 자원을 격리해 새로운 OS를 실행
- 게스트 OS : 이렇게 설치되 실행된 OS, 호스트 OS의 리소스를 나눈 논리적인 공간
    - 일반적으로 가상 머신이라고 부름
    - 웹서버나 WAS, DB 같은 서버 프로그램을 프로세스로 실행, 운영

`하이퍼바이저의 동작 원리`

1. 프로세스는 정상적으로 실행되기 위해 CPU, 메모리 같은 리소스를 사용해야 함
2. 하드웨어를 사용하기 위해서는 OS를 통해서만 사용 가능하며 커널(Kernal)이라는 중요한 도구가 설치
3. 사용 요청을 대신 전달해주는 시스템 콜(System Call)을 보내 하드웨어의 자원을 사용
4. 각각의 OS (Window, Linux, MacOS)들은 다른 종류의 커널을 사용하며 시스템 콜도 다름
5. 가상화 기술을 사용해 윈도우 호스트 OS에서 게스트 OS로 맥 OS, 리눅스를 실행해야 한다면?
6. 게스트 OS의 커널은 실제로 물리적인 하드웨어가 없기때문에 리소스를 사용하려면 호스트 OS의 커널로 리소스 사용을 요청 해야함
7. 여기서 하이퍼바이저가 다른 커널 간의 언어를 통역해주는 통역가 역할을 수행

### 컨테이너 가상화

컨테이너 가상화는 리눅스 커널이 제공하는 LXC 라는 자체 격리 기술에서 출발

- LXC 기술을 사용하면 하이퍼바이저를 사용하지 않고도 커널의 자체 기능만 사용해 격리 공간을 만들수 있음
- 커널의 네임스페이스와 Cgroups라는 기능을 활용
    - 네임스페이스 : 프로세스, 하드드라이브, 네트워크, 사용자, 호스트 네임처럼 리소스를 나누는 기준의 역할
    - Cgroups : 프로세스가 사용하는 메모리, CPU, 하드디스크, 네트워크처럼 리소스의 사용량을 배분하는 기술
- **이런 LXC 기술을 사용해 만들어진 각각의 격리된 공간을 컨테이너라고 부름**

<aside>
💡 **컨테이너 가상화는 커널의 격리 기능을 활용 → 모든 컨테이너는 호스트 OS의 커널을 공유해서 사용**

**각각의 컨테이너들은 자체적인 커널이 없고 호스트 OS의 커널을 공유해 커널을 실행하는 시간 자체가 X → 빠른 부팅속도, 적은 오버헤드**

</aside>

### 도커(Docker)

컨테이너 가상화 기술을 사용하기 위한 오픈소스 소프트웨어

- 도커와 같은 컨테이너 가상화 도구를 컨테이너 플랫폼이라고 부르며 컨테이너 엔진과 컨테이너 런타임으로 구성
    - 컨테이너 엔진 : 사용자의 요청을 받아 컨테이너를 관리
    - 컨테이너 런타임 : 직접 커널과 통신하며 실제로 격리된 공간을 만듬 (도커는 runc라는 기본 컨테이너 런타임을 지원)
- 도커는 점유율이 가장 높은 컨테이너 플랫폼

![20240625_155250](https://github.com/boyfromthewell/docker-study/assets/86250281/30aa1794-88c0-4334-9c18-7fb2163b495d)


`도커는 클라이언트-서버 모델로 실행`

- 도커에도 사용자의 명령을 전달해주는 클라이언트와 실제로 컨테이너를 관리해주는 도커 데몬(Docker Daemon)이라는 서버가 존재
- 도커 데몬 또한 컨테이너를 관리하기 위해 API 명세를 제공, 하지만 사용자가 API를 직접 사용하기엔 번거로움
- **Docker CLI 라는 command line 툴이 제공** → 명령어에 따라 서버의 API 양식에 맞게 만들어 대신 전달

### 컨테이너 실행

1. **Clinent, Server의 버전 및 상태 확인**

```powershell
docker version
```

![20240625_160821](https://github.com/boyfromthewell/docker-study/assets/86250281/ef478e7b-bcdf-4441-aa80-051fdf92eba7)


1. **플러그인 시스템 상세 정보 확인**

```powershell
docker info
```

![20240625_160949](https://github.com/boyfromthewell/docker-study/assets/86250281/07a87acd-8df1-47f6-a4e8-6cf0041fef1c)


서버 응답 같은 경우는 현재 실행 중인 컨테이너, 이미지 개수, 사용중인 플러그인, 도커가 실행 중인 시스템의 OS 타입과 CPU 아키텍쳐 등을 제공

1. **명령어 메뉴얼 확인**

```powershell
docker --help
```

도커의 명령어는 도커, 매니지먼트 커맨트, 커맨드 부분으로 분류

```powershell
docker (Management Command) Command 
ex) docker container run,,,
```

매니지먼트 커맨드는 일반적으로 생략이 가능함

명령어가 잘 기억이 나지 않으면 —help 명령어로 가이드 제공 받을수 있음

```powershell
docker container --help
docker container run --help
```

1. **컨테이너 실행**

```docker
docker run (실행옵션) 이미지명
```

예시)

```docker
docker run -p 80:80 --name hellonginx nginx
```

![20240625_162412](https://github.com/boyfromthewell/docker-study/assets/86250281/b56b6cf3-1b1c-462f-9d49-d73b68f2b65f)


방금 실행했던 nginx에서 제공해 준 파일

1. **컨테이너 삭제**

```docker
docker rm 컨테이너명/ID
```

예시)

```docker
docker rm hellonginx
```
